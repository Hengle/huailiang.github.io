<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>自动化导出c++各个平台库</title>
    <meta name="description" content="  在上面一节，我们学习了c++和c#混合编程，主要是针对windows平台。接下来我们会讲下在其他平台c++库在Unity中使用的方法。unity可以使用的ios静态库（.a） android 静态库（.so） mac下的bundle库。上面的库导出以后，放在Unity Plugins目录下，Unity在编译包...">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://huailiang.github.io/blog/2018/exportcpp/">
    <link rel="alternate" type="application/rss+xml" title="Huailiang Blog" href="https://huailiang.github.io/feed.xml" />
  </head>

  <body>
    <main>
      <header class="site-header">
  <div class="container">
    <h1><a href="/">Hom<span>e</span></a></h1>

    <button type="button" class="sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </button>

    <nav class="navbar sliding-panel-content">
      <ul>
        
        <li><a href="/about" title="About">About</a>
        </li>
        
        <li><a href="/blog" title="Blog">Blog</a>
        </li>
        
        <!-- <li><a href="https://github.com/huailiang/archive/master.zip" title="Download">Download</a></li> -->
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>

<div class="sliding-panel-fade-screen"></div>

      <div class="container">
        <article role="article" class="post">

  <div class="card">
    <header class="post-header">
      <h1 class="post-title">自动化导出c++各个平台库</h1>
      <p class="post-meta">Mar 1, 2018 •
        Huailiang</p>
    </header>

    <div class="post-content">
      <blockquote>
  <p>在上面一节，我们学习了c++和c#混合编程，主要是针对windows平台。接下来我们会讲下在其他平台c++库在Unity中使用的方法。unity可以使用的ios静态库（.a） android 静态库（.so） mac下的bundle库。上面的库导出以后，放在Unity Plugins目录下，Unity在编译包或者在编辑器里运行的时候会自动对应相应的库。</p>
</blockquote>

<p>unity 使用 在 Plugins 目录最终层级结构如下图所示：</p>

<p><img src="/img/in-post/post-cpp/cpp14.png" alt="" /></p>

<h2 id="android-生成so">Android 生成so</h2>

<p>Android平台下，c++代码生成.so库，我们这里主要是使用ndk的方法。 NDK 是在SDK前面又加上了“原生”二字，即Native Development Kit，因此又被Google称为NDK。  随着Android的蓬勃发展, CPU的架构也越来越多. 早期只支持ARMv5, 截至目前, 支持的架构已达三类七种: ARM(ARMv5，ARMv7 (从2010年起)，ARMv8), x86(x86 (从2011年起),x86_64 (从2014年起)) ,MIPS(MIPS (从2012年起),MIPS64). 众多架构使用的指令集不尽相同, 与相应的ABI关联: armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, mips, mips64. 所以, NDK编译不同架构的库要选择不同的ABI。 不过Unity5之后，导出的包只会有ARMv7和x86两种架构了，我们在配置的时候，也就只需考虑这两种结构就可以了。 而大红大紫的《王者荣耀》就更过分了，我们解开他们的apk之后，发现他们只有arm-v7这一种so,说明不常用的x86手机已经被他们无情的抛弃了。</p>

<p><img src="/img/in-post/post-cpp/cpp13.jpg" alt="" /></p>

<p>你可以到<a href="https://developer.android.com/ndk/downloads/index.html">官网下载NDK</a>, 下载完成之后需要设置一些环境变量：</p>

<pre><code class="language-shell">export NDK_HOME=/home/echosea/Desktop/Android/android-ndk-r12
export PATH=$NDK_HOME:$PATH
</code></pre>

<p>创建Application.mk和Android.mk文件<br />
Application.mk文件，可以用来配置编译平台相关内容，它用来指定我们需要基于哪些CPU架构的.so文件，当然你可以配置多个平台：</p>

<pre><code class="language-shell">APP_ABI          := armeabi armeabi-v7a x86
APP_OPTIM         := release
APP_PLATFORM      := android-8

# GNU STL implements most C++11 features. Use either gnustl_static or gnustl_shared
# Without this your C++ code will not be able to access headers like &lt;thread&gt;, &lt;mutex&gt;
#APP_STL      := stlport_static
#APP_CPPFLAGS := -std=c++11 -frtti -fexceptions
APP_STL       := gnustl_static
APP_CPPFLAGS  := -std=gnu++11 -pthread -frtti -fexceptions
#-NDEBUG -mfpu=neon -fomit-frame-pointer
 -DNDEBUG  
</code></pre>

<p>配置Android.mk文件，用来指定源码编译的配置信息，例如工作目录，编译模块的名称，参与编译的文件等，大致内容如下：</p>
<pre><code class="language-shell"># Copyright (C)
# Author: huailiang.peng
# Date:	  2017-11-25
# Function:	make c++ code to so
#

LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

#so 文件名
LOCAL_MODULE   := GameCore

#  c++目录的相对路径
MY_FILES_PATH  :=  $(LOCAL_PATH)/../../XCPP/GameCore

#$(warning $(MY_FILES_PATH))

# c++后缀
MY_FILES_SUFFIX := %.cpp %.c

# 递归遍历目录下的所有的文件
rwildcard=$(wildcard $1$2) $(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2))

# 获取相应的源文件
MY_ALL_FILES := $(foreach src_path,$(MY_FILES_PATH), $(call rwildcard,$(src_path),*.*) )
MY_ALL_FILES := $(MY_ALL_FILES:$(MY_CPP_PATH)/./%=$(MY_CPP_PATH)%)
MY_SRC_LIST  := $(filter $(MY_FILES_SUFFIX),$(MY_ALL_FILES))
MY_SRC_LIST  := $(MY_SRC_LIST:$(LOCAL_PATH)/%=%)

# 去除字串的重复单词
define uniq =
  $(eval seen :=)
  $(foreach _,$1,$(if $(filter $_,${seen}),,$(eval seen += $_)))
  ${seen}
endef

# 递归遍历获取所有目录
MY_ALL_DIRS := $(dir $(foreach src_path,$(MY_FILES_PATH), $(call rwildcard,$(src_path),*/) ) )
MY_ALL_DIRS := $(call uniq,$(MY_ALL_DIRS))

# 赋值给NDK编译系统
LOCAL_SRC_FILES  := $(MY_SRC_LIST)
LOCAL_C_INCLUDES := $(MY_ALL_DIRS)

#在这里设置宏
LOCAL_CFLAGS := -D__ANDROID__

# Add additional include directories
LOCAL_C_INCLUDES += $(LOCAL_PATH)/../../
#LOCAL_C_INCLUDES += $(LOCAL_PATH)/../../../Eigen-3.2.2   
#必须从Android.mk配置文件中拿掉对Eigen的直接包含，放到程序代码中用相对路径包含：
# #include "../../Eigen-3.2.2/Eigen"
# using namespace Eigen;

#$(warning $(LOCAL_SRC_FILES))
#$(warning $(LOCAL_C_INCLUDES))

# use log system in NDK
LOCAL_LDLIBS += -llog

include $(BUILD_SHARED_LIBRARY)

</code></pre>

<p>其中<br />
LOCAL_MODULE表示模块名称<br />
LOCAL_SRC_FILES表示需要参与编译的源文件<br />
除了这两个，其他照搬即可</p>

<h4 id="ndk-build">NDK-build</h4>
<p>android ndk构建系统依赖于GUN make工具对模块进行构建，默认情况下，GUN make工具一次执行一条构建命令，等这一句执行完了以后再执行下一句，如果我们使用-j参数，GUN make就可以并行执行构建命令。<br />
cd 到jni的上一级目录，使用命令ndk-build, 自动生成了，libs目录<br />
<img src="/img/in-post/post-cpp/cpp18.png" alt="" /></p>

<p>不过 build 之前，最好 clean一下，保证环境的纯净。</p>

<pre><code class="language-shell">$ ndk-build clean
$ ndk-build
</code></pre>

<h3 id="mac下生成bundle">Mac下生成Bundle</h3>

<p>创建 mac支持的 c++库，我们新建一个 xcode 工程，选择 macOS一栏，选择 Bunlde 一侧. 如下图所示：<br />
<img src="/img/in-post/post-cpp/cpp15.png" alt="" /></p>

<p>创建好之后，我们把 windows 中vs 里使用的 c++代码拖到 xcode 工程中,这里使用引用就可以了，没有必要 copy 一份新的到 xcode</p>

<p><img src="/img/in-post/post-cpp/cpp19.png" alt="" /></p>

<p>设置好自己使用的Architecture,如果顺利的话，你就可以编译到bundle 库了</p>

<p><img src="/img/in-post/post-cpp/cpp16.png" alt="" /></p>

<p>在 products 目录下右键*.bundle 在 Show in Finder ,将生成的 bundle 复制到 unity 项目 plugins 目录下，就大工告成了。</p>

<h3 id="生成ios-a静态库">生成IOS .a静态库</h3>

<p>创建 ios支持的 c++库，我们新建一个 xcode 工程，选择 iOS一栏，选择 .a 一侧. 注意，ios 我们这里使用的是静态库，而非像其他平台是动态链接库。如下图所示：<br />
<img src="/img/in-post/post-cpp/cpp20.png" alt="" /><br />
其他的操作跟 macos 相同。编译成功之后我们可以看到 products 目录多出了 gamecore.a<br />
<img src="/img/in-post/post-cpp/cpp22.png" alt="" /></p>

<p>下面借助一段Shell脚本就可以导出和合并生成.a 并且 copy 到 Plugins目录下：</p>

<pre><code class="language-shell">#
#	i386｜x86_64 是Mac处理器的指令集，i386是针对intel通用微处理器32架构的。x86_64是针对x86架构的64位处理器 这两个是ios模拟器使用
#	standard architectures (including 64-bit)(armv7,arm64)
#	Build Active Architecture Only  指定是否只对当前连接设备所支持的指令集编译. 当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本
#	编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的
#

# !/bin/sh

path=/Users/huailiang.peng/Documents/unity/dn_asset

cd ${path}

cd tools_proj/IOS/GameCore

echo "xcode clean "

rm -r libGameCore.a

xcodebuild clean

echo "xcode build"

echo "start build for iphoneos"

#编译 release 版本的.a
xcodebuild -configuration "Release" -target GameCore -sdk iphoneos clean build

eho "start build for simulator"

#编译 release 版本的.a
xcodebuild -configuration "Release" -target GameCore -sdk iphonesimulator clean build

echo "build success"

echo "merge diff start library"

lipo -create build/Release-iphoneos/libGameCore.a build/Release-iphonesimulator/libGameCore.a -output libGameCore.a

lipo -info libGameCore.a

echo "make libGameCore.a success"

echo "start mv to unity Plugins dir"

mv -f libGameCore.a ${path}/Assets/Plugins/iOS/libGameCore.a

echo "done, bye!"

</code></pre>

<p>macos 和 ios 的库都是在xcode 中手动生成的，不符合我们自动化的流程，我们生成版本时，如果中间每次都是手动操作的话，也很容易出错。那有没有一套自动化的流程，既省时，又能保证版本质量呢，答案是肯定的。</p>

<h3 id="cmake交差编译">cmake交差编译</h3>
<p>CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。这里使用的是CMake，官网地址为：<a href="https://cmake.org/">https://cmake.org/</a></p>

<p>MAC默认是没有cmake指令的。要测试你的MAC是否已经装过cmake，可以这样做：打开Terminal，输入cmake –version，如果已经安装，则会显示具体的版本号；否则就是没安装或者没配置成功。</p>

<p>以 OSX平台为例，下面展示:</p>

<p>CMakeLists.txt：</p>

<pre><code class="language-c">cmake_minimum_required(VERSION 3.0.2)
#project(GameCore)

include_directories(${CMAKE_CURRENT_SOURCE_DIR})

file(GLOB_RECURSE source_cpp_files "${CMAKE_CURRENT_SOURCE_DIR}/../XCPP/GameCore/*.cpp")
file(GLOB_RECURSE source_c_files "${CMAKE_CURRENT_SOURCE_DIR}/../XCPP/GameCore/*.c")

# 设置使用 C++11 标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)


# 编译 Debug 模式还是 Release 模式
set(CMAKE_BUILD_TYPE Release)

# 根据 OSX、Android、iOS 等不同平台，分别设置不同的配置
if (OSX)
    message("is building osx platform")

    include(CheckCXXCompilerFlag)  
    CHECK_CXX_COMPILER_FLAG("-std=c++11" COMPILER_SUPPORTS_CXX11)  
    CHECK_CXX_COMPILER_FLAG("-std=c++0x" COMPILER_SUPPORTS_CXX0X)  
    if(COMPILER_SUPPORTS_CXX11)  
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")  
    elseif(COMPILER_SUPPORTS_CXX0X)  
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")  
    else()  
         message(STATUS "The compiler ${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.")  
    endif()  

    add_library(GameCore MODULE ${source_cpp_files} ${source_c_files})

    # OSX 下面的 Unity 插件要是 GameCore.bundle 格式的
    set_target_properties(GameCore PROPERTIES BUNDLE TRUE)

    # 设置代码库的输出路径
    set(OUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/out/OSX/)

    # 添加编译使用的宏
    ADD_DEFINITIONS(-D__MACH__)

elseif(IOS)
    message("is building ios platform")

	add_library(GameCore STATIC ${source_cpp_files} ${source_c_files})

    # 设置编译器, 由于 iOS 和 OSX 使用的是相同的编译器，所以此处设置为 Mac 上的Clang 的路径
    # 但是对于 Android 来讲，交叉编译的环境为 NDK 的编译器环境，所以需要对 Android 设置为 NDK 下面的编译器路径。
    set(CMAKE_C_COMPILER clang)
    set(CMAKE_CXX_COMPILER clang++)
    # bitcode 设置为 NO
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fembed-bitcode")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fembed-bitcode")

    # 最低支持的 iOS 版本
    set(CMAKE_XCODE_ATTRIBUTE_IPHONEOS_DEPLOYMENT_TARGET "7.1")

    # 支持的指令架构
    set(CMAKE_OSX_ARCHITECTURES "armv7 armv7s arm64")

    # 使用哪个 iOS SDK 进行打包，这里需要注意是对 iPhone 真机打包还是 iPhone 模拟器打包，二者的 SDK 是不同的。
    # 我们这里使用的是 iPhone 真机的 SDK。
    set(CMAKE_OSX_SYSROOT /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk)

    # 设置代码库的输出路径
    set(OUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/out/iOS/)

    # 添加编译使用的宏
    ADD_DEFINITIONS(-D__iOS__)

elseif(ANDROID)
    message("is building android platform")

    add_library(GameCore SHARED ${source_cpp_files} ${source_c_files})

    # 由于 Unity 在 Android 下面对 C++ 只支持 .so 的动态库格式，
    # 而如果你用 Mac 机编译时，默认的动态库格式为 .dylib,
    # 所以我们需要显示的使用 .so 后缀。
    set_target_properties(GameCore PROPERTIES SUFFIX ".so")

    # 设置代码库的输出路径
    set(OUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/out/Android/${ANDROID_ABI}/)

    # 添加编译使用的宏
    ADD_DEFINITIONS(-D__ANDROID__)

else()
    message("warn: unknown platform")
    message(${CMAKE_SYSTEM})
    add_library(GameCore STATIC ${source_cpp_files} ${source_c_files})
    set(OUT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/out/else/)
endif()


# 设置代码库的输出路径, 对 Debug 和 Release 模式都设置成同一个路径
set_target_properties(GameCore PROPERTIES
        LIBRARY_OUTPUT_DIRECTORY ${OUT_PATH}
        ARCHIVE_OUTPUT_DIRECTORY ${OUT_PATH}
        LIBRARY_OUTPUT_DIRECTORY_RELEASE ${OUT_PATH}
        ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${OUT_PATH}
        LIBRARY_OUTPUT_DIRECTORY_DEBUG ${OUT_PATH}
        ARCHIVE_OUTPUT_DIRECTORY_DEBUG ${OUT_PATH}
        LIBRARY_OUTPUT_DIRECTORY_RELEASE ${OUT_PATH}
        ARCHIVE_OUTPUT_DIRECTORY_RELEASE ${OUT_PATH}
        )

</code></pre>

<p>生成 ios 静态库，还需要配置一个 toolchain文件,你可以在这里<a href="https://github.com/zilongshanren/Box2D-cocos2d-x/blob/master/Box2D/toolchain/">点击下载</a>。然后使用如下命令，生成 ios 工程：</p>

<pre><code class="language-shell">#generate ios project
cmake -DCMAKE_TOOLCHAIN_FILE=toolchains/ios.toolchain.cmake -DIOS_PLATFORM=iPhoneOS -DCMAKE_OSX_ARCHITECTURES='armv7 armv7s arm64' -GXcode

</code></pre>

<p>好了，到这里就结束了，拿到 xcode 工程，之后使用xcodebuild编译出库，所有的流程都是Shell 在后台帮我们完成了，我们需要做的就是喝咖啡等待最终的结果了。</p>


    </div>

  </div>

</article>
      </div>

      <footer class="site-footer">
  <div class="container">
    <ul class="social">
  <li><a href="https://github.com/huailiang" target="_blank"><i class="icon icon-github"></i></a></li>
  <li><a href="https://twitter.com/penghuailiang" target="_blank"><i class="icon icon-twitter"></i></a></li>
  <li><a href="https://www.facebook.com/profile.php?id=100004290725320" target="_blank"><i class="icon icon-facebook"></i></a></li>
  <li><a href="https://www.linkedin.com/in/penghuailiang/" target="_blank"><i class="icon icon-linkedin"></i></a></li>
</ul>
    <p class="txt-medium-gray">
      <small>&copy;2019 All rights reserved. Made with <a href="https://huailiang.github.io/"
          target="_blank">Huailiang</a> and ♥</small>
    </p>
  </div>
</footer>

      <a href="https://github.com/huailiang" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#337ab7; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

      <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
      <script>
      $(document).ready(function() {
        $('.sliding-panel-button,.sliding-panel-fade-screen,.sliding-panel-close').on('click touchstart',function (e) {
          $('.sliding-panel-content,.sliding-panel-fade-screen').toggleClass('is-visible');
          e.preventDefault();
        });
      });
      </script>
    </main>
  </body>
</html>
